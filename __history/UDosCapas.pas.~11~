unit UDosCapas;

interface

Uses
  ZDataSet, DBClient, Variants;

Type
  TTipoSentencia = (ccCatalog, ccSelect, ccUpdate, ccLocate);

function CrearConjunto(DataSet: TZQuery; Tabla: String; Tipo: TTipoSentencia): boolean; overload;
function CrearConjunto(DataSet: TZReadOnlyQuery; Tabla: String; Tipo: TTipoSentencia): boolean; overload;

implementation

Uses
  frm_Connection;

var
  QuerySentencias: TClientDataSet;
  QueryRead: TZReadOnlyQuery;

procedure CrearDatosSentencias;
var
  i: Integer;
begin
  QueryRead := TZReadOnlyQuery.Create(Nil);
  QuerySentencias := TClientDataSet.Create(Nil);

  QueryRead.Connection := Connection.ConnTrx;
  QueryRead.SQL.Text := 'select sTablaPrimaria, sTipo, lStatus, sIdentificador, sSentencia from nuc_sentencias where sTablaPrimaria = :Tabla and sTipo = :Tipo';
  QueryRead.ParamByName('Tabla').AsString := '-9';
  QueryRead.ParamByName('Tipo').AsString := '-9';

  if Connection.ConnTrx.Connected and Not Connection.ConnTrx.Ping then
    Connection.ConnTrx.Reconnect;

  // Leer la estructura de la tabla de sentencias
  try
    if QueryRead.Active then
      QueryRead.Refresh
    else
      QueryRead.Open;
    for i := 0 to QueryRead.FieldDefs.Count -1 do
      QuerySentencias.FieldDefs.Add(QueryRead.FieldDefs.Items[i].Name, QueryRead.FieldDefs.Items[i].DataType, QueryRead.FieldDefs.Items[i].Size, QueryRead.FieldDefs.Items[i].Required);
    QuerySentencias.CreateDataSet;
    QuerySentencias.Open;
  finally
    QueryRead.Close;
  end;
end;

function GetSentence(Tabla: string; Tipo: string): String;
var
  Resultado: String;
  i: Integer;
begin
  Resultado := '';

  // Localizar la sentencia en base a los parametros indicados
  Try
    Try
      if (Not Assigned(QuerySentencias)) or (Not QuerySentencias.Active) then
        CrearDatosSentencias;

      // Verificar si la sentencia ya se ha leido
      if Not QuerySentencias.Locate('sTablaPrimaria;sTipo', VarArrayOf([Tabla, Tipo]), []) then
      begin
        // Si no encuentra la sentencia se deberá agregar a la memoria
        QueryRead.Close;
        QueryRead.ParamByName('sTabla').AsString := Tabla;
        QueryRead.ParamByName('sTipo').AsString := Tipo;
        QueryRead.Open;

        // Verificar si la sentencia existe realmente
        if QueryRead.RecordCount = 0 then
        begin
          // Si la sentencia no existe entonces se deberá crear una sentencia por default
          QuerySentencias.Append;
          QuerySentencias.FieldByName('sTablaPrimaria').AsString := Tabla;
          QuerySentencias.FieldByName('sTipo').AsString := Tipo;
          QuerySentencias.FieldByName('lStatus').AsString := 'Activo';
          QuerySentencias.FieldByName('sIdentificador').AsString := '';
          QuerySentencias.FieldByName('sSentencia').AsString := 'SELECT * FROM ' + Tabla;
          QuerySentencias.Post;
        end
        else
        begin
          // Si la sentencia existe se deberá agregar a la tabla
          QuerySentencias.Append;
          for i := 0 to QuerySentencias.FieldDefs.Count -1 do
            QuerySentencias.FieldByName(QuerySentencias.FieldDefs.Items[i].Name).AsString := QueryRead.FieldByName(QuerySentencias.FieldDefs.Items[i].Name).AsString;
          QuerySentencias.Post;
        end;
      end;

      Resultado := QuerySentencias.FieldByName('sSentencia').AsString;
    Except
      Resultado := 'SELECT * FROM ' + Tabla
    End;
  Finally
    Result := Resultado;
  End;
end;

function CrearConjunto(DataSet: TZQuery; Tabla: String; Tipo: TTipoSentencia): Boolean;
var
  MaxNumero, i: Integer;
  LocTipo: String;
begin
  Result := False;

  // Crear el Query asignandolo a la conexión local del servidor
  Try
    DataSet.Connection := Connection.ConnTrx;
    if DataSet.Connection.Connected and Not DataSet.Connection.Ping then
      DataSet.Connection.Reconnect;

    case Tipo of
      ccCatalog: LocTipo := 'CATALOGO';
      ccSelect: LocTipo := 'SELECT';
      ccUpdate: LocTipo := 'UPDATE';
      ccLocate: LocTipo := 'LOCATE';
    end;

    DataSet.SQL.Text := GetSentence(Tabla, LocTipo);

    // Poner todos los parametros a -1 para acceder a todo el catálogo por default
    for i := 0 to DataSet.Params.Count - 1 do
      DataSet.Params.Items[i].Value := '-1';

    {if Tipo = stUpdate then
    begin
      DataSet.BeforePost := GlobalBeforePost;
      DataSet.AfterPost := GlobalAfterPost;
      DataSet.BeforeDelete := GlobalBeforeDelete;
      DataSet.AfterDelete := GlobalAfterDeleteCancelScroll;
      DataSet.OnPostError := GlobalPostError;
      // LocQuery.AfterScroll  := GlobalAfterInsert;
    end;
    DataSet.BeforeOpen := GlobalBeforeOpen;
    DataSet.AfterOpen := GlobalAfterOpen;}

    Result := True; // Solo si llega a este punto del proceso es que ambos objetos fueron creado satisfactoriamente
  Except
    raise; // Siendo este un error de programación, es necesario informar de ello
  End;
end;

function CrearConjunto(DataSet: TZReadOnlyQuery; Tabla: String; Tipo: TTipoSentencia): Boolean;
begin
  CrearConjunto(TZQuery(DataSet), Tabla, Tipo);
end;

end.
